## 前言

开始记录自己每周的学习，打算以周刊的形式记录下来，好记性不如烂笔头，日拱一卒，等以后老了的时候，再回过来头看也许是一份美好的回忆。

20220319 第一周

## 1、每周看至少学习五篇操作系统源码文章


第一部分：进入内核前的苦力活

第1回 最开始的两行代码
第2回 自己给自己挪个地儿
第3回 做好最最基础的准备工作
第4回 把自己在硬盘里的其他部分也放到内存来
第5回 进入保护模式前的最后一次折腾内存

地址：https://github.com/sunym1993/flash-linux0.11-talk


## 2、每周末至少2道算法题
- 中序后序构造二叉树 https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/
思路：递归
- 抓奶牛：https://vjudge.net/problem/POJ-3278 
思路：BFS
- 129. 求根节点到叶节点数字之和 https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/ 
思路：后序遍历

## 3、每周至少学习一篇技术专栏
本周学习的极客时间《左耳听风》专栏

缓存是提高性能最好的方式，一般来说，缓存有以下三种模式。

**Cache Aside 更新模式**

这是最常用的设计模式了，其具体逻辑如下。
- 失效：应用程序先从 Cache 取数据，如果没有得到，则从数据库中取数据，成功后，放到缓存中。
- 命中：应用程序从 Cache 中取数据，取到后返回。
- 更新：先把数据存到数据库中，成功后，再让缓存失效。

那么，是不是这个 Cache Aside 就不会有并发问题了？不是的。比如，一个是读操作，但是没有命中缓存，就会到数据库中取数据。而此时来了一个写操作，写完数据库后，让缓存失效，然后之前的那个读操作再把老的数据放进去，所以会造成脏数据。这个案例理论上会出现，但实际上出现的概率可能非常低

**Read/Write Through 更新模式**

Read/Write Through 套路是把更新数据库（repository）的操作由缓存自己代理了，所以，对于应用层来说，就简单很多了。可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的 Cache。

**Write Behind Caching 更新模式Write Behind 又叫 Write Back。**

一些了解 Linux 操作系统内核的同学对 write back 应该非常熟悉，这不就是 Linux 文件系统的 page cache 算法吗？是的，你看基础知识全都是相通的。所以，基础很重要，我已经说过不止一次了。Write Back 套路就是，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是让数据的 I/O 操作飞快无比（因为直接操作内存嘛）。因为异步，Write Back 还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。但其带来的问题是，数据不是强一致性的，而且可能会丢失

**关于缓存的一些注意点**

- 在分布式架构下，一般都需要一个外部的缓存集群。关于这个缓存集群，你需要保证的是内存要足够大，网络带宽也要好，因为缓存本质上是个内存和 IO 密集型的应用。
- 另外，如果需要内存很大，那么你还要动用数据分片技术来把不同的缓存分布到不同的机器上。
- 缓存的好坏要看命中率。缓存的命中率高说明缓存有效，一般来说命中率到 80% 以上就算很高了。
- 另外，缓存是通过牺牲强一致性来提高性能的。
- 缓存数据的时间周期也需要好好设计，太长太短都不好，过期期限不宜太短，因为可能导致应用程序不断从数据存储检索数据并将其添加到缓存。同样，过期期限不宜太长，因为这会导致一些没人访问的数据还在内存中不过期，而浪费内存。
- 使用缓存的时候，一般会使用 LRU 策略。也就是说，当内存不够需要有数据被清出内存时，会找最不活跃的数据清除。所谓最不活跃的意思是最长时间没有被访问过了。所以，开启 LRU 策略会让缓存在每个数据访问的时候把其调到前面，而要淘汰数据时，就从最后面开始淘汰。

链接：http://gk.link/a/11gbZ

本周学习《趣谈Linux操作系统》第30讲-38讲 输入输出系统-进程见通信

**进程间通信**

- 匿名管道 + 有名管道
- 消息队列
- 共享内存
- 信号量
- 信号
- socket

链接：http://gk.link/a/11gkr


## 4、每周末至少健身30分钟（目前户外跑步为主）
Keep打卡 5km 完成 

